package com.build.stats.utils

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.repository.findByIdOrNull
import java.time.LocalDateTime


/**
 * Returns this value or value generated by [defaultValueProvider] if this is null.
 */
inline fun <T> T?.orElse(defaultValueProvider: () -> T): T {
    return this ?: defaultValueProvider()
}

/**
 * Returns this or throw exception if this is null. [messageProvider]
 * can be used for specific exception message.
 */
fun <T> T?.retrieveRequired(messageProvider: (() -> String)? = null): T {
    return this ?: throw IllegalStateException(
        messageProvider?.invoke() ?: DEFAULT_ENTITY_IS_ABSENT_MSG
    )
}

/**
 * Returns this or throw exception if this is null. [messageProvider]
 * can be used for specific exception message.
 */
@Suppress("unchecked_cast")
fun <O, T> O?.retrieveRequiredAs(messageProvider: (() -> String)? = null): T {
    return this as? T ?: throw IllegalStateException(
        messageProvider?.invoke() ?: DEFAULT_ENTITY_IS_ABSENT_MSG
    )
}

/**
 * Returns a [page] of [pageSize] from this list or an empty list.
 */
fun <O, T : List<O>> T.getPage(page: Int?, pageSize: Int?): List<O> {
    require(page != null && pageSize != null)
    require(page > 0 && pageSize > 0)

    ifEmpty { return emptyList() }

    val start = (page - 1) * pageSize
    val end = if (start + pageSize >= size) size else start + pageSize

    return if (start <= end) {
        return toList().subList(start, end)
    } else emptyList()
}

/**
 * Returns an interval [from]..[to].
 */
fun prepareInterval(from: LocalDateTime?, to: LocalDateTime?): ClosedRange<LocalDateTime> {
    val dateFrom = from ?: LocalDateTime.MIN
    val dateTo = to ?: LocalDateTime.MAX

    require(dateFrom <= dateTo) {
        "Incorrect date range provided: $from, $to"
    }
    return dateFrom..dateTo
}

/**
 * Retrieves required entity of type [T] with [id] or throws corresponding exception.
 */
inline fun <reified T, ID> JpaRepository<T, ID>.findRequiredById(id: ID): T {
    return findByIdOrNull(id)
        .retrieveRequired {
            "Can't find required entity of" +
                    " type ${T::class.simpleName} with id [$id]"
        }
}

private const val DEFAULT_ENTITY_IS_ABSENT_MSG = "Entity is marked as required, but null"